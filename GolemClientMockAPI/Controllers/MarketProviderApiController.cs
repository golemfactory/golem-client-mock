/*
 * Yagna Market API
 *
 *  ## Yagna Market The Yagna Market is a core component of the Yagna Network, which enables computational Offers and Demands circulation. The Market is open for all entities willing to buy computations (Demands) or monetize computational resources (Offers). ## Yagna Market API The Yagna Market API is the entry to the Yagna Market through which Requestors and Providers can publish their Demands and Offers respectively, find matching counterparty, conduct negotiations and make an agreement.  This version of Market API conforms with capability level 1 of the <a href=\"https://docs.google.com/document/d/1Zny_vfgWV-hcsKS7P-Kdr3Fb0dwfl-6T_cYKVQ9mkNg\"> Market API specification</a>.  Market API contains two roles: Requestors and Providers which are symmetrical most of the time (excluding agreement phase). 
 *
 * OpenAPI spec version: 1.4.2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Primitives;
using Swashbuckle.AspNetCore.SwaggerGen;
using Newtonsoft.Json;
using System.ComponentModel.DataAnnotations;
using GolemClientMockAPI.Attributes;
using GolemMarketMockAPI.MarketAPI.Models;
using Swashbuckle.AspNetCore.Annotations;
using GolemClientMockAPI.Security;
using GolemClientMockAPI.Processors;
using GolemClientMockAPI.Repository;
using GolemClientMockAPI.Mappers;

namespace GolemMarketMockAPI.Controllers
{
    /// <summary>
    /// 
    /// </summary>
    [ApiController]
    [Produces("application/json")]
    [GolemClientAuthorizationFilter(DefaultNodeId = "DummyProviderNodeId")]
    //[Authorize(AuthenticationSchemes = ApiKeyAuthenticationHandler.SchemeName)]
    public class MarketProviderApiController : Controller
    {

        public IProviderMarketProcessor MarketProcessor { get; set; }
        public ISubscriptionRepository SubscriptionRepository { get; set; }
        public IProposalRepository ProposalRepository { get; set; }
        public IAgreementRepository AgreementRepository { get; set; }

        public MarketProviderEventMapper ProviderEventMapper { get; set; }
        public DemandMapper DemandMapper { get; set; }
        public OfferMapper OfferMapper { get; set; }

        public MarketProviderApiController(IProviderMarketProcessor marketProcessor,
            ISubscriptionRepository subscriptionRepository,
            IProposalRepository proposalRepository,
            IAgreementRepository agreementRepository,
            MarketProviderEventMapper providerEventMapper,
            OfferMapper offerMapper,
            DemandMapper demandMapper)
        {
            this.MarketProcessor = marketProcessor;
            this.SubscriptionRepository = subscriptionRepository;
            this.ProposalRepository = proposalRepository;
            this.AgreementRepository = agreementRepository;
            this.ProviderEventMapper = providerEventMapper;
            this.OfferMapper = offerMapper;
            this.DemandMapper = demandMapper;
        }


        /// <summary>
        /// Approves Agreement proposed by the Reqestor.
        /// </summary>
        /// <remarks>This is a blocking operation.  It returns one of the following options: * &#x60;Ok&#x60; - Indicates that the approved Agreement has been successfully delivered to the Requestor and acknowledged.   - The Requestor side has been notified about the Provider's commitment     to the Agreement.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Requestor's corresponding ConfirmAgreement call returns Ok after     the one on the Provider side.  * &#x60;Cancelled&#x60; - Indicates that before delivering the approved Agreement, the Requestor has called &#x60;cancelAgreement&#x60;, thus invalidating the Agreement. The Provider may attempt to return to the Negotiation phase by sending a new Proposal.  **Note**: It is expected from the Provider node implementation to "ring-fence" the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Ok&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. </remarks>
        /// <param name="agreementId"></param>
        /// <param name="timeout"></param>
        /// <response code="204">Agreement approved.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="409">Agreement already rejected.</response>
        /// <response code="410">Agreement cancelled by the Requstor.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpPost]
        [Route("/market-api/v1/agreements/{agreementId}/approve")]
        [ValidateModelState]
        [SwaggerOperation("ApproveAgreement")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult ApproveAgreement([FromRoute][Required]string agreementId, [FromQuery]float? timeout)
        { 
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            // locate the agreement
            var agreement = this.AgreementRepository.GetAgreement(agreementId);

            if (agreement == null)
            {
                return StatusCode(404, new ErrorMessage() { }); // Not Found
            }

            if (clientContext.NodeId != agreement.OfferProposal.Offer.NodeId)
            {
                return StatusCode(401, new ErrorMessage() { }); // Unauthorized
            }

            var agreementEntity = this.MarketProcessor.ApproveAgreement(agreementId); // TODO: , timeout ?? 10.0);

            if(agreementEntity.State == GolemClientMockAPI.Entities.AgreementState.Cancelled)
            {
                return StatusCode(410, new ErrorMessage() { });
            }

            return StatusCode(200, agreementEntity.State.ToString());
        }

        /// <summary>
        /// Reads Market responses to published Offer.
        /// </summary>
        /// <remarks>This is a blocking operation. It will not return until there is at least one new event.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. </remarks>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout"></param>
        /// <param name="maxEvents"></param>
        /// <response code="200">Proposal or Agreement event list.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpGet]
        [Route("/market-api/v1/offers/{subscriptionId}/events")]
        [ValidateModelState]
        [SwaggerOperation("CollectDemands")]
        [SwaggerResponse(statusCode: 200, type: typeof(List<Event>), description: "Proposal or Agreement event list.")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual async Task<IActionResult> CollectDemands([FromRoute][Required]string subscriptionId, [FromQuery]float? timeout, [FromQuery]int? maxEvents)
        {
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            var subscription = this.SubscriptionRepository.GetOfferSubscription(subscriptionId);

            if (subscription == null)
            {
                return StatusCode(404, new ErrorMessage() { }); // Not Found
            }

            if (clientContext.NodeId != subscription.Offer.NodeId)
            {
                return StatusCode(401, new ErrorMessage() { }); // Unauthorized
            }

            var events = await this.MarketProcessor.CollectProviderEventsAsync(subscriptionId, timeout, (int?)maxEvents);

            var result = events.Select(proposal => this.ProviderEventMapper.Map(proposal))
                                   .ToList();

            // Return the collected requestor events (including offer proposals)
            return StatusCode(200, result);
        }

        /// <summary>
        /// Responds with a bespoke Offer to received Demand.
        /// </summary>
        /// <remarks>Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. </remarks>
        /// <param name="body"></param>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <response code="201">Counter Proposal created.</response>
        /// <response code="400">Bad request.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="410">Proposal rejected.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpPost]
        [Route("/market-api/v1/offers/{subscriptionId}/proposals/{proposalId}")]
        [ValidateModelState]
        [SwaggerOperation("CreateProposalOffer")]
        [SwaggerResponse(statusCode: 201, type: typeof(string), description: "Counter Proposal created.")]
        [SwaggerResponse(statusCode: 400, type: typeof(ErrorMessage), description: "Bad request.")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult CreateProposalOffer([FromBody]Proposal offerProposal, [FromRoute][Required]string subscriptionId, [FromRoute][Required]string proposalId)
        {
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            var subscription = this.SubscriptionRepository.GetOfferSubscription(subscriptionId);

            if (subscription == null)
            {
                return StatusCode(404, new ErrorMessage() { }); // Not Found
            }

            if (clientContext.NodeId != subscription.Offer.NodeId)
            {
                return StatusCode(401, new ErrorMessage() { }); // Unauthorized
            }

            var offerEntity = new GolemClientMockAPI.Entities.Offer()
            {
                NodeId = clientContext.NodeId,
                Constraints = offerProposal.Constraints,
                Properties = PropertyMappers.MapFromJsonString(offerProposal.Properties?.ToString())
            };

            try
            {
                var offerProposalEntity = this.MarketProcessor.CreateOfferProposal(subscriptionId, proposalId, offerEntity);

                return StatusCode(201, offerProposalEntity.Id);
            }
            catch (Exception exc)
            {
                return StatusCode(404, new ErrorMessage() { Message = $"creating offer proposal: {proposalId}, {offerEntity} error: {exc.Message}" }); // Not Found
            }
        }

        /// <summary>
        /// Fetches all active Offers which have been published by the Provider.
        /// </summary>
        /// <response code="200">Offer list.</response>
        /// <response code="400">Bad request.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpGet]
        [Route("/market-api/v1/offers")]
        [ValidateModelState]
        [SwaggerOperation("GetOffers")]
        [SwaggerResponse(statusCode: 200, type: typeof(List<>), description: "Offer list.")]
        [SwaggerResponse(statusCode: 400, type: typeof(ErrorMessage), description: "Bad request.")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected ErrorMessage.")]
        public virtual IActionResult GetOffers()
        {
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            var subscriptions = this.SubscriptionRepository.GetActiveOfferSubscriptions(clientContext.NodeId);

            try
            {
                var offers = subscriptions.Select(subs => this.OfferMapper.MapEntityToModel(subs));

                return StatusCode(201, offers);
            }
            catch (Exception exc)
            {
                return StatusCode(0, new ErrorMessage() { }); // unexpecetd ErrorMessage
            }
        }


        /// <summary>
        /// Fetches Proposal (Demand) with given id.
        /// </summary>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <response code="200">Proposal.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="410">Proposal rejected.</response>
        /// <response code="0">Unexpected ErrorMessage.</response>
        [HttpGet]
        [Route("/market-api/v1/offers/{subscriptionId}/proposals/{proposalId}")]
        [ValidateModelState]
        [SwaggerOperation("GetProposalDemand")]
        [SwaggerResponse(statusCode: 200, type: typeof(Proposal), description: "Proposal.")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult GetProposalDemand([FromRoute][Required]string subscriptionId, [FromRoute][Required]string proposalId)
        {
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            var subscription = this.SubscriptionRepository.GetOfferSubscription(subscriptionId);

            if (subscription == null)
            {
                return StatusCode(404, new ErrorMessage() { }); // Not Found
            }

            if (clientContext.NodeId != subscription.Offer.NodeId)
            {
                return StatusCode(401, new ErrorMessage() { }); // Unauthorized
            }

            var demandProposal = this.ProposalRepository.GetDemandProposals(subscriptionId).Where(prop => prop.Id == proposalId).FirstOrDefault();

            if (demandProposal == null)
            {
                return StatusCode(404, new ErrorMessage() { }); // Not Found
            }

            var offerProposal = (demandProposal.OfferId == null) ?
                                    new GolemClientMockAPI.Entities.OfferProposal() { Id = subscriptionId, Offer = subscription.Offer } :
                                    this.ProposalRepository.GetOfferProposal(demandProposal.OfferId);

            var result = this.DemandMapper.MapEntityToProposal(demandProposal);

            return StatusCode(200, result);
        }

        /// <summary>
        /// Handles dynamic property query.
        /// </summary>
        /// <remarks>The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the "dynamic" properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side's requested properties as the context of the query.  **Note**: The property query responses may be submitted in "chunks", ie. the responder may choose to resolve "quick"/lightweight" properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. </remarks>
        /// <param name="body"></param>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <response code="204">OK, query reply posted.</response>
        /// <response code="400">Bad request.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpPost]
        [Route("/market-api/v1/offers/{subscriptionId}/propertyQuery/{queryId}")]
        [ValidateModelState]
        [SwaggerOperation("PostQueryReplyOffers")]
        [SwaggerResponse(statusCode: 400, type: typeof(ErrorMessage), description: "Bad request.")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult PostQueryReplyOffers([FromBody]PropertyQueryReply body, [FromRoute][Required]string subscriptionId, [FromRoute][Required]string queryId)
        { 
            //TODO: Uncomment the next line to return response 204 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(204);

            //TODO: Uncomment the next line to return response 400 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(400, default(ErrorMessage));

            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401, default(ErrorMessage));

            //TODO: Uncomment the next line to return response 404 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(404, default(ErrorMessage));

            //TODO: Uncomment the next line to return response 0 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(0, default(ErrorMessage));

            throw new NotImplementedException();
        }

        /// <summary>
        /// Rejects Agreement proposed by the Requestor.
        /// </summary>
        /// <remarks>The Requestor side is notified about the Provider's decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. </remarks>
        /// <param name="agreementId"></param>
        /// <response code="204">Agreement rejected.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="409">Agreement already approved.</response>
        /// <response code="410">Agreement cancelled by the Requstor.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpPost]
        [Route("/market-api/v1/agreements/{agreementId}/reject")]
        [ValidateModelState]
        [SwaggerOperation("RejectAgreement")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult RejectAgreement([FromRoute][Required]string agreementId)
        {
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            // locate the agreement
            var agreement = this.AgreementRepository.GetAgreement(agreementId);

            if (agreement == null)
            {
                return StatusCode(404, new ErrorMessage() { }); // Not Found
            }

            if (clientContext.NodeId != agreement.OfferProposal.Offer.NodeId)
            {
                return StatusCode(401, new ErrorMessage() { }); // Unauthorized
            }

            this.MarketProcessor.RejectAgreement(agreementId);

            return StatusCode(204);
        }

        /// <summary>
        /// Rejects Proposal (Demand).
        /// </summary>
        /// <remarks>Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. </remarks>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <response code="204">Proposal rejected.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="410">Proposal already rejected.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpDelete]
        [Route("/market-api/v1/offers/{subscriptionId}/proposals/{proposalId}")]
        [ValidateModelState]
        [SwaggerOperation("RejectProposalDemand")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult RejectProposalDemand([FromRoute][Required]string subscriptionId, [FromRoute][Required]string proposalId)
        { 
            //TODO: Uncomment the next line to return response 204 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(204);

            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401, default(ErrorMessage));

            //TODO: Uncomment the next line to return response 404 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(404, default(ErrorMessage));

            //TODO: Uncomment the next line to return response 410 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(410);

            //TODO: Uncomment the next line to return response 0 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(0, default(ErrorMessage));

            throw new NotImplementedException();
        }

        /// <summary>
        /// Publishes Provider capabilities via Offer.
        /// </summary>
        /// <remarks>Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. </remarks>
        /// <param name="body"></param>
        /// <response code="201">Subscribed.</response>
        /// <response code="400">Bad request.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpPost]
        [Route("/market-api/v1/offers")]
        [ValidateModelState]
        [SwaggerOperation("SubscribeOffer")]
        [SwaggerResponse(statusCode: 201, type: typeof(string), description: "Subscribed.")]
        [SwaggerResponse(statusCode: 400, type: typeof(ErrorMessage), description: "Bad request.")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult SubscribeOffer([FromBody]Offer body) 
        {
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            var offerEntity = this.OfferMapper.MapToEntity(body);

            offerEntity.NodeId = clientContext.NodeId;

            var subscription = this.MarketProcessor.SubscribeOffer(offerEntity);

            // return created Subscription Id
            return StatusCode(201, subscription.Id);
        }


        /// <summary>
        /// Stop subscription for previously published Offer.
        /// </summary>
        /// <remarks>Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. </remarks>
        /// <param name="subscriptionId"></param>
        /// <response code="204">Offer revoked.</response>
        /// <response code="401">Authorization information is missing or invalid.</response>
        /// <response code="404">The specified resource was not found.</response>
        /// <response code="410">Already unsubscribed.</response>
        /// <response code="0">Unexpected error.</response>
        [HttpDelete]
        [Route("/market-api/v1/offers/{subscriptionId}")]
        [ValidateModelState]
        [SwaggerOperation("UnsubscribeOffer")]
        [SwaggerResponse(statusCode: 401, type: typeof(ErrorMessage), description: "Authorization information is missing or invalid.")]
        [SwaggerResponse(statusCode: 404, type: typeof(ErrorMessage), description: "The specified resource was not found.")]
        [SwaggerResponse(statusCode: 0, type: typeof(ErrorMessage), description: "Unexpected error.")]
        public virtual IActionResult UnsubscribeOffer([FromRoute][Required]string subscriptionId)
        {
            var clientContext = this.HttpContext.Items["ClientContext"] as GolemClientMockAPI.Entities.ClientContext;

            var subscription = this.SubscriptionRepository.GetOfferSubscription(subscriptionId);

            if (subscription == null)
            {
                return StatusCode(404, new ErrorMessage() { }); // Not Found
            }

            if (clientContext.NodeId != subscription.Offer.NodeId)
            {
                return StatusCode(401, new ErrorMessage() { }); // Unauthorized
            }

            this.MarketProcessor.UnsubscribeOffer(subscriptionId);

            return StatusCode(204);
        }
    }
}
